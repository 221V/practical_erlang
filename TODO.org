
* TODO exercise 14. OTP фреймворк
создать базовый проект из одного приложения, как у меня erl_proj_tpl
app-sup-worker и т.д.

в начале один только Makefile, который умеет собирать и запускать ноду

тест должен проверить, что все собирается, запускается,
к ноде можно подключиться, выполнить which_applications
и worker отвечает на пинг инфой
еще можно проверить дерево супервизоров

простой вариант -- шифрование xor по ключу
хранить в ген-сервере ключ. АПИ чтобы менять его.
передаешь строку, он возвращает шифрованную

вариант: herd_rand:uuid/0
https://ru.wikipedia.org/wiki/UUID
gen_server тут нужен, чтобы инициализировать в нем рандомайзер

вариант: морзе код


* TODO exercise 15. Обработка ошибок на разных уровнях


* TODO exercise 16. TCP и UDP сокеты
  telnet-клиент
  tcp-сервер в пассивном режиме с текстовым протоколом
  бродкаст на всех клиентов


* TODO курсовая работа
  консольная 2048 http://habrahabr.ru/post/261801/
  telnet-client, TCP-socket, ranch
  Может быть какой-то многопользовательский вариант игры.
  Или что-то из Codewars.

  игра в города между двумя пользователями
  сервер передает инфу между ними, и сделит за правилами:
  - новый город начинается с той буквы, на которую закончился старый
  - города не повторяются
  нужно придумать какой-то простой текстовый протокол
  и придумать, как соединять пользователей в пары


* TODO video

** TODO 7. io_list, binary, string, unicode

** TODO 8. Многопоточность в Erlang.

** TODO 9. gen_server

** TODO 10. gen_server, продолжение

** TODO 11. link, monitor

** TODO 12. supervisor

** TODO 13. application

** TODO 14. OTP фреймворк

** TODO 15. Обработка ошибок на разных уровнях

** TODO 16. TCP и UDP сокеты


* TODO Когда курс будет закончен, вывести из sanbox на hexlet
  Дать ссылку на github/yzh44yzh/practial_erlang в своем блоге и своих аккаунтах (гуглоплюс, фейсбукс и т.д.)


* Инфа

https://github.com/yzh44yzh/practical_erlang/

https://ru.hexlet.io/courses/erlang_101

Дока:
https://github.com/Hexlet/docs/blob/master/create-lesson.md

Dockerfile для установки Erlang, Rebar, Relx
https://registry.hub.docker.com/u/correl/erlang/dockerfile/


* урок по валидации входящих данных
вложенные case
исключения
схемы
erlmonads
и то, как я сделал для отписок в NC


* урок по raft


* Designing for <anything> with Erlang
https://medium.com/@dmitriid/designing-for-anything-with-erlang-cfadb6833bc0#.ctwsdsq0g

пост о том, чего не хватает в книгах по эрлангу

it would be really nice to read up on at least some of these things:
    setting up multiple nodes
    testing a distributed app
    deploying a distributed app
    handling failover
    handling load balancing
    handling netsplits (and not only in Mnesia. If we can add a process on node B to a gen_supervisor on node A, how do we handle netsplits, timeouts, restarts etc.?)
    discovery of nodes
    tracing
    profiling
    various VM options and their impact
    securing connection between nodes
    logging
    debugging
    crash dumps
    remote inspection
    mitigating overflowing mailboxes
    SSL
    sockets
    working from behind firewalls
    flood protection
    slow requests
    timeouts
    sessions
    latency
    <add your own>


* мнение питониста после 1 месяца знакомства с эрланг


Привожу субъективное мнение одного Python-разработчика о языке Erlang после пары месяцов разработки на этом языке.

Erlang не понравился потому, что:
1) обладает ужасным синтаксисом, который заставляет страдать(особенно доставляют запятые и балланс скобок различного типа);
-> замедляется скорость написания кода

2) генерирует невменяемые сообщения об ошибках, в которых много бесполезной информации и иногда отсутствует нужная информация для понимания проблемы;
-> замедляется скорость отладки

3) имеет плохую и довольно бедную стандартную библиотеку(после Python) с некоторыми кривыми legacy-типами данных, которые ни в коем случае нельзя использовать(например array);
-> замедляется скорость написания кода

4) довольно сложно писать код в функциональном стиле(не понятно, как реализовать довольно простые вещи без помощи опытного товарища);
-> замедляется скорость написания кода

5) сторонние библиотеки-акселераторы довольно часто кривые или их нет вообще;
-> удлинняется цикл разработки приложения

6) непонятно, как писать производительный код на Erlang: циклов нет, есть куча копирований списков на ровном месте,  тяжело оценить алгоритмическую сложность полученного решения;
-> большие риски написания кривого медленного кода, которые нужно компенсировать интенсивными бенчмарками
