# Обработка ошибок на низком уровне

Одна из главных фич эрланг -- устойчивость к ошибкам (fault
tolerance).  Считается, что система, сделанная на эрланг, может легко
переживать ошибки в коде и в данных, аппаратные сбои, сбои в сети, и
продолжать обслуживать клиентов.

Это не значит, что любой код на эрланг сразу обладает такими
свойствами.  Об этом должен позаботиться программист. А эрланг только
дает средства, которыми программист может обеспечить устойчивость.
Давайте посмотрим, что это за средства.


## link

Устойчивость к ошибкам построена на способности потоков наблюдать друг
за другом.  Два потока можно связать друг с другом так, что при
падение одного, второй получит специальное сообщение и тоже упадет.

Можно связать группу потоков, так, что при падении одного из них,
упадет вся группа. Предполагается, что потоки зависят друг от друга в
своей работе. Отсутствие одного потока приводит к нештатной ситуации,
в которой остальные не могут выполнять осмысленных действий. Они
только усугубляют и распространяют проблемы. Так что лучше остановить
и рестартовать всю группу.

Информация о падении передается в системном сообщении, тем же
способом, что и обычные сообщения между потоками. Но системные сообщения
(их еще называют **сигналы**), не попадают в почтовый ящик. Их нельзя
обработать обычным способом. Вместо этого, они просто завершают поток,
который их получил, и распространяются дальше по имеющимся связям.

При нормальной остановке потока сигнал распространяется, но не
вызывает завершение связанных потоков.

Вызов **link(Pid)** создает связь между текущим потоком и Pid.
Связь двухстороннаяя. Чтобы связать несколько потоков, нужно сделать
несколько вызовов link. Если потоки уже связаны, то вызов link не
оказывает никакого эффекта.

Вызов **unlink(Pid)** разрывает связь.

Часто бывает нужно создать новый поток и связь с ним. Это можно сделать
последовательными вызовами spawn и link. Но поток может завершиться
до вызова link. Поэтому лучше использовать функцию **spawn_link**,
которая объединяет эти две операции, но выполняется атомарно.


TODO: пример кода
стартовать несколько потоков и связать все
показать, что они работают
сделать краш одного из них
показать, что все завершились


## Системные потоки

Связи -- это хорошо, но этого мало. Еще нужно разделение ролей между
потоками.  Одни потоки (рабочие), делают что-то полезное. Другие
потоки (системные), присматривают за состоянием рабочих потоков.

Чтобы сделать поток системным, достаточно вызывать:
```erlang
process_flag(trap_exit, true)
```

При этом в метаданных потока устанавливается специальный флаг
**trap_exit**. После этого сигналы превращаются в обычные сообщения и
попадают в почтовый ящик.  Таким образом системный поток может
обработать падение рабочего потока.

Сообщения выглядят так:
```erlang
{'EXIT', Pid, Reason}
```

Кортеж из 3х элеметов. Первый -- атом 'EXIT', второй -- Pid потока,
который завершился, третий -- причина завершения потока.


TODO: пример кода


## Завершение работы потока

нормально

краш

exit

-spec exit(Reason) -> none()
-spec exit(Pid, Reason) -> none()


While you can trap most exit reasons, there are situations where you
might want to brutally murder a process: maybe one of them is trapping
exits but is also stuck in an infinite loop, never reading any
message. The kill reason acts as a special signal that can't be
trapped. This ensures any process you terminate with it will really be
dead. Usually, kill is a bit of a last resort, when everything else
has failed.

As the kill reason can never be trapped, it needs to be changed to
killed when other processes receive the message. If it weren't changed
in that manner, every other process linked to it would in turn die for
the same kill reason and would in turn kill its neighbors, and so
on. A death cascade would ensue.

When a system process receives a kill signal, it terminates. Kill signals
are generated by calling exit(Pid, kill) . This signal bypasses the normal error
signal processing mechanism and is not converted into a message. The
exit kill signal should be reserved for rogue processes that refuse to die
using any of the other error handling mechanisms.

Таблицу лучше представить в виде серии картинок

|--------------+--------------------------------+-------------------------------|
| Reason       | trap_exit=true                 | trap_exit=false               |
|--------------+--------------------------------+-------------------------------|
| exit(normal) | Receives {'EXIT', Pid, normal} | Nothing happens               |
|--------------+--------------------------------+-------------------------------|
| exit(kill)   | Terminates with reason killed  | Terminates with reason killed |
|--------------+--------------------------------+-------------------------------|
| exit(Other)  | Receives {'EXIT', Pid, Other}  | Terminates with reason Other  |
|--------------+--------------------------------+-------------------------------|

## monitor

More seriously, monitors are a special type of link with two differences:
- they are unidirectional;
- they can be stacked.

Monitors are what you want when a process wants to know what's going
on with a second process, but neither of them really are vital to each
other.

Reference = erlang:monitor(process, Pid)

{'DOWN', Reference, process, Pid, Reason}

erlang:demonitor(Ref, [flush, info]).

The info option tells you if a monitor existed or not when you tried to remove it.
demonitor returned false.
Using flush as an option will remove the DOWN message from the mailbox if it existed

monitoring process
does not have to become a system process in order to handle errors.

Repeated calls to erlang:monitor(process,Pid) will return different ref-
erences, creating multiple independent monitors. They will all send their 'DOWN' mes-
sage when Pid terminates.

## Заключение

Низкоуровневые функции **link/unlink** почти не используются на
практике. Но базе **link** и **trap_exit** построен супервизор --
высокоуровневое средство для обработки ошибок.  Это тема следующего
урока.

TODO: криво сформулировано
**monitor** на практике используется, когда нам нужна специфическая
обработка завершения потока. Супервизор просто рестартует поток,
но не предоставляет возможности для такой обработки.
