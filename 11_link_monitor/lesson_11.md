# Обработка ошибок на низком уровне

Одна из главных фич эрланг -- устойчивость к ошибкам (fault
tolerance).  Считается, что система, сделанная на эрланг, может легко
переживать ошибки в коде и в данных, аппаратные сбои, сбои в сети, и
продолжать обслуживать клиентов.

Это не значит, что любой код на эрланг сразу обладает такими
свойствами.  Об этом должен позаботиться программист. А эрланг только
дает средства, которыми программист может обеспечить устойчивость.
Давайте посмотрим, что это за средства.


## link

Устойчивость к ошибкам построена на способности потоков наблюдать друг
за другом. Два потока можно связать друг с другом так, что при падение
одного из них, второй получит специальное сообщение, и тоже упадет.

Можно связать группу потоков, так, что при падении одного из них,
упадет вся группа. Предполагается, что потоки зависят друг от друга в
своей работе. Отсутствие одного потока приводит к нештатной ситуации,
в которой остальные не могут выполнять осмысленных действий. Они
только усугубляют и распространяют проблемы. Так что лучше остановить
и рестартовать всю группу.

TODO: анекдот про трех мужиков, сажающих деревья, один не пришел.

Информация о падении передается в системном сообщении, тем же
способом, что и обычные сообщения между потоками. Но системные
сообщения не попадают в почтовый ящик, и их нельзя обработать обычным
способом. Вместо этого, они просто завершают поток, который их
получил, и распространяются дальше по имеющимся связям.

При нормальной остановке потока системное сообщение не генерируется, и
связанные потоки продолжают работать.

**link/1**, which takes a Pid as an argument. When called, the
  function will create a link between the current process and the one
  identified by Pid.

**unlink/1**

Links can not be stacked. If you call link/1 15 times for the same two
processes, only one link will still exist between them and a single
call to unlink/1 will be enough to tear it down.

-spec spawn_link(Fun) -> Pid
-spec spawn_link(Mod, Fnc, Args) -> Pid

-spec exit(Reason) -> none()
-spec exit(Pid, Reason) -> none()

TODO: пример кода


## system processes

In order to restart a process, we need a way to first know that it
died. This can be done by adding a layer on top of links (the
delicious frosting on the cake) with a concept called system
processes. System processes are basically normal processes, except
they can convert exit signals to regular messages. This is done by
calling process_flag(trap_exit, true) in a running process.

By writing programs using system processes, it is easy to create a
process whose only role is to check if something dies and then restart
it whenever it fails.

There are two types of processes, normal processes and system processes.
spawn creates a normal process. A normal process can become a system
process by evaluating the BIF process_flag(trap_exit, true).

**System processes** are basically normal processes, except they can
convert exit signals to regular messages. This is done by calling
process_flag(trap_exit, true) in a running process.

-spec process_flag(trap_exit, true)

сигнал 'EXIT' превращает в сообщение 'EXIT', которое можно обработать.

{'EXIT', Pid, Reason}

TODO: пример кода


## kill

While you can trap most exit reasons, there are situations where you
might want to brutally murder a process: maybe one of them is trapping
exits but is also stuck in an infinite loop, never reading any
message. The kill reason acts as a special signal that can't be
trapped. This ensures any process you terminate with it will really be
dead. Usually, kill is a bit of a last resort, when everything else
has failed.

As the kill reason can never be trapped, it needs to be changed to
killed when other processes receive the message. If it weren't changed
in that manner, every other process linked to it would in turn die for
the same kill reason and would in turn kill its neighbors, and so
on. A death cascade would ensue.

When a system process receives a kill signal, it terminates. Kill signals
are generated by calling exit(Pid, kill) . This signal bypasses the normal error
signal processing mechanism and is not converted into a message. The
exit kill signal should be reserved for rogue processes that refuse to die
using any of the other error handling mechanisms.

Таблицу лучше представить в виде серии картинок

|--------------+--------------------------------+-------------------------------|
| Reason       | trap_exit=true                 | trap_exit=false               |
|--------------+--------------------------------+-------------------------------|
| exit(normal) | Receives {'EXIT', Pid, normal} | Nothing happens               |
|--------------+--------------------------------+-------------------------------|
| exit(kill)   | Terminates with reason killed  | Terminates with reason killed |
|--------------+--------------------------------+-------------------------------|
| exit(Other)  | Receives {'EXIT', Pid, Other}  | Terminates with reason Other  |
|--------------+--------------------------------+-------------------------------|

## monitor

More seriously, monitors are a special type of link with two differences:
- they are unidirectional;
- they can be stacked.

Monitors are what you want when a process wants to know what's going
on with a second process, but neither of them really are vital to each
other.

Reference = erlang:monitor(process, Pid)

{'DOWN', Reference, process, Pid, Reason}

erlang:demonitor(Ref, [flush, info]).

The info option tells you if a monitor existed or not when you tried to remove it.
demonitor returned false.
Using flush as an option will remove the DOWN message from the mailbox if it existed

monitoring process
does not have to become a system process in order to handle errors.

Repeated calls to erlang:monitor(process,Pid) will return different ref-
erences, creating multiple independent monitors. They will all send their 'DOWN' mes-
sage when Pid terminates.

## Заключение

Низкоуровневые функции **link/unlink** почти не используются на
практике. Но базе **link** и **trap_exit** построен супервизор --
высокоуровневое средство для обработки ошибок.  Это тема следующего
урока.

TODO: криво сформулировано
**monitor** на практике используется, когда нам нужна специфическая
обработка завершения потока. Супервизор просто рестартует поток,
но не предоставляет возможности для такой обработки.
