# gen_server, продолжение

Мы реализовали свой gen_server, теперь пора посмотреть на настоящий :)

Наш gen_server стостоит из 3х частей:
- внешнее АПИ (start/0, add\_item/2, remove\_item/2, show\_items/2, stop/1)
- общая (generic) часть (call/2)
- хранение состояния и обработка собщений (loop/1)

Первые 2 части выполняются в потоке клиента, 3-я часть выполняется в
потоке сервера.

Настоящий gen\_server устроен сложнее. Код также делится на общую
(generic) часть, и кастомную часть. Общая часть реализована в
нескольких модулях OTP фреймворка (gen\_server, gen,
proc\_lib). Кастомную часть мы должны реализовать в своем модуле.

![gen_server](http://yzh44yzh.github.io/img/practical_erlang/gen_server.png)

На картинке два левых квадрата (верхний и нижний), соответствуют
нашему модулю.  Два правых квадрата соответствуют коду OTP. Два
верхних квадрата выполняются в потоке клиента, два нижних квадрата
выполняются в потоке сервера.

Левый верхний квадрат -- это публичное АПИ нашего модуля. Отсюда мы
обращаемся к OTP фреймворку. В кастомной реализации, которую мы делали
на прошлом уроке, этот квадрат соответствует функциям start,
add\_item, remove\_item, show\_items.

Правый верхний квадрат -- это часть OTP, generic код, выполняющийся
в потоке клиента. Соответствует функции call в нашей кастомной реализации.

Правый нижний квадрат -- это часть OTP, выполняющаяся в потоке сервера.
Соответствует функции loop в нашей реализации. Только там нет кастомной
обработки сообщений. А вместо этого OTP вызывает функции обратного вызова
(callback) нашего модуля.

Левый нижний квадрат -- функции обратного вызова, принадлежащие нашему модулю,
и работающие в потоке сервера.

**behaviour** в эрланг -- это аналог интерфейсов в джава. Он
описывает, какие callback-функции должны быть определены, их имена и
аргументы.

**-behaviour(gen_server)** требует, чтобы наш модуль определил функции
init/1, handle\_call/3, handle\_cast/2, handle\_info/2, terminate/2 и code\_change/3.

Дальше мы разберем, как взаимодействуют наш модуль и gen\_server.
на примере модуля
[wg\_push\_sender](https://github.com/wgnet/wg_push/blob/master/src/wg_push_sender.erl),
из
[библиотеки wg_push](https://github.com/wgnet/wg_push/).
Это библиотека для отправки сообщений на iOS устройства через
Apple Push Notification Service.


## инициализация

Все начинается с функции **start\_link/0**:

```erlang
start_link() ->
    gen_server:start_link({local, ?MODULE}, ?MODULE, [], []).
```

Здесь мы просим gen\_server запустить новый поток.

Макрос **?MODULE** разворачивается в имя текущего модуля.
Можно было написать:
```erlang
gen_server:start_link({local, wg_push_sender}, wg_push_sender, [], []).
```
получится тоже самое.

Первый аргумент **{local, ?MODULE}** -- это имя, под которым нужно
зарегистрировать поток.  Ну это если мы хотим обращаться к нашему
серверу по имени. Иначе вызываем gen\_server:start\_link/3, и
созданный поток не будет регистрироваться.

Второй аргумент **?MODULE** -- это имя модуля, callback-функции
которого будет вызывать gen\_server.

Третий аргумент -- это набор параметров, которые нужны при
инициализации.  В нашем случае никакие не нужны.

Четверный аргумент -- настройки поведения gen\_server. Они довольно
специфичны, и необходимость что-то в них менять не возникает. Но
загляните в документацию, это полезно :)

Дальше происходит некая магия в правом верхнем квадрате, в результате
которой создается серверный поток. Этому потоку нужно получить свое
начальное состояние.  Для этого вызывается первый callback **init/1**.

```erlang
init([]) ->
    {ok, #state{
            apns_host = application:get_env(wg_push, apns_host, "gateway.sandbox.push.apple.com"),
            apns_port = application:get_env(wg_push, apns_port, 2196)
           }}.
```

Аргумент init, это данные, которые мы передавали третьим аргументом в
gen\_server:start\_link.  Здесь нужно создать структуру данных,
которая будет хранить состояние сервера.

Часто для этого описывают record с именем **state**.

```erlang
-record(state, {
        apns_host :: string(),
        apns_port :: integer(),
        connections = orddict:new() :: orddict:orddict(file:name_all(), port())
         }).
```

После того, как функция init возвращает #state, сервер готов к работе.


## gen_server:call

Теперь посмотрим, как делается запрос от клиента к серверу, на примере
API-функции send_messages.

```erlang
send_messages(Messages, SSL_Options) ->
    gen_server:call(?MODULE, {send_messages, Messages, SSL_Options}).
```

Здесь мы вызываем gen_server:call с двумя аргументами. Первый аргумент
-- pid сервера или имя, под которым он зарегистрирован. Второй
аргумент -- сообщение, которое посылается серверу.

В недрах OPT вызов проходит через call и loop, и затем вызывается
callback-функция handle_call. Ей передаются три аргумента: сообщение
от клиента, кортеж {pid клиента, reference} и состояние сервера.
Второй аргумент обычно не используется.

```erlang
handle_call({send_messages, Messages, SSL_Options}, _From, State) ->
    {Reply, State3} = send_messages(Messages, SSL_Options, State),
    {reply, Reply, State3};
```

handle_call должен обработать сообщение, сформировать ответ для клиента и
новое состояние для сервера.

Есть несколько вариантов возвращаемого значения. Но мы сейчас не будем рассматривать
редкие случаи. Чаще всего мы отвечаем {reply, Reply, NewState}.

Обычно каждой АПИ функции модуля соответствует отдельное сообщение, а каждому сообщению
отдельный клоз handle\_call. Если АПИ большое, то и клозов handle\_call много.

```erlang
my_api_1(A) ->
    gen_server:call(?MODULE, {msg1, A}).
my_api_2(A, B) ->
    gen_server:call(?MODULE, {msg2, A, B}).
my_api_3(A, B, C) ->
    gen_server:call(?MODULE, {msg3, A, B, C}).
...
handle_call({msg1, A}, _From, State) ->
...
handle_call({msg2, A, B}, _From, State) ->
...
handle_call({msg3, A, B, C}, _From, State) ->
```

Поэтому внутри handle\_call много кода лучше не писать, а выносить его в отдельные функции.


## другие callback-функции

### gen_server:cast/handle_cast

Вызов gen_server:call блокирует клиента, пока сервер не обработает его запрос и не вернет ответ.
Бывают случаи, когда клиенту ответ сервера не нужен. Тогда лучше использовать gen\_server:cast.
Клиент не блокируется и не ждет ответ сервера. Но сервер получает и обрабатыват сообщение.

Для этого вызывается callback-функция handle_cast:

```erlang
do_something(A, B) ->
    gen_server:cast(?MODULE, {do_something, A, B}),
    ok.
...
handle_cast({do_something, A, B}, State) ->
    NewState = ...
    {noreply, NewState};
```

handle_cast должен вернуть измененное состояние.


### message/handle_info

Любой поток из любого места в код может отправить серверу сообщение
оператором **!**.  Так делать не рекомендуется, потому что это вызовы
в обход API сервера.  Но иногда так делают.

Если сообщения в функции loop сервера приходят не из gen\_server:call/cast,
то они обрабатываются в callback-функции handle\_info.

```erlang
handle_info({some_message, A, B}, State) ->
    NewState = ...
    {noreply, NewState};
```

Сервер и сам может отправлять себе сообщения таким образом. Например,
для отложенной инициализации (это мы рассмотрим ниже), или для
выполнения повторяющихся операций через интервалы времени.


### terminate
TODO

### code_change
TODO


## Отложенная инициализация

Вызов init блокирует родительский поток, причем с timeout = infinity
по умолчанию. Желательно оставлять эту функцию легковесной и
возвращать управление родителю как можно быстрее.

Если инициализация сервера требует долгих действий, то такие вещи
лучше делать отложено.

```
init(Args) ->
    State = ...
    self() ! heavy_init,
    {ok, State}.

handle_info(heavy_init, State) ->
    NewState = ...
    {noreply, NewState};
```

Устанавливать соединение с базой данных, запрашивать какие-то данные из внешнего
источника, создавать большие объекты в памяти -- все это стоит делать отложено.


## сравнение с ООП


## Deadlock на gen_server:call

С этим сталкивается почти каждый новичок в Erlang. И я тож столкнулся.

Нельзя делать gen\_server:call на самого себя внутри handle\_call.
Бывают более сложные варианты, когда из handle\_call вызвается какая-то функция,
и уже в ней, или где-то в цепочке вызовов gen\_server:call.

TODO объяснить, почему нельзя

TODO вот в этом нюансе аналогия с ООП хромает
