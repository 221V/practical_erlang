# gen_server, продолжение

Мы реализовали только часть gen_server, а именно **gen_server:call/handle_call**.

API gen_server еще включает:

**start/init**
TODO

**cast/handle_cast**
TODO

**message/handle_info**
TODO

**terminate**
TODO

**code_change**
TODO

Но и это еще не все. В стандартной реализации gen\_server есть возможность
сделать call/cast на несколько нод в кластере; есть возможность запаковать
состояние, чтобы оно занимало меньше места в памяти и другие фишки.

TODO 3 части:
- внешнее АПИ, выполняется в потоке клиента
- общая (generic) часть, выполняется в потоке сервера
  в нашей реализации представлена функцией call.
  в настоящей реализации все сложнее, код размазан по 3м модулям и нескольким функциям
- кастомные обработчики сообщений
  в нашей реализации -- функция loop
  в настойщей реализации -- handle\_call, handle\_cast, handle\_info

TODO сравнение с ООП


## Пример настоящего модуля.

реализующего поведение gen_server
https://github.com/yzh44yzh/e_prof/blob/master/src/e_prof.erl


## Отложенная инициализация

Вызов init блокирует родительский процесс, причем с timeout = infinity
по умолчанию. Желательно оставлять эту функцию легковесной и
возвращать управление родителю как можно быстрее.

Если инициализация сервера требует долгих действий, то такие вещи
лучше делать отложено.

```
init(Args) ->
    State = ...
    self() ! heavy_init,
    {ok, State}.

handle_info(heavy_init, State) ->
    NewState = ...
    {noreply, NewState};
```

Устанавливать соединение с базой данных, запрашивать какие-то данные из внешнего
источника, создавать большие объекты в памяти -- все это стоит делать отложено.


## Deadlock на gen_server:call

С этим сталкивается почти каждый новичок в Erlang. И я тож столкнулся.

Нельзя делать gen\_server:call на самого себя внутри handle\_call.
Бывают более сложные варианты, когда из handle\_call вызвается какая-то функция,
и уже в ней, или где-то в цепочке вызовов gen\_server:call.

TODO объяснить, почему нельзя

TODO вот в этом нюансе аналогия с ООП хромает
