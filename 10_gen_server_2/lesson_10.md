# gen_server, продолжение

Мы реализовали свой gen_server, теперь пора посмотреть на настоящий :)

Наш gen_server стостоит из 3х частей:
- внешнее АПИ (start/0, add\_item/2, remove\_item/2, show\_items/2, stop/1)
- общая (generic) часть (call/2)
- хранение состояния и обработка собщений (loop/1)

Первые 2 части выполняются в потоке клиента, 3-я часть выполняется в
потоке сервера.

Настоящий gen\_server устроен сложнее. Код тоже делится на общую
(generic) часть, и кастомную часть. Общая часть реализована в
нескольких модулях OTP фреймворка (gen\_server, gen,
proc\_lib). Кастомную часть мы должны реализовать в своем модуле.

И сейчас мы разберем, как взаимодействуют наш модуль и gen\_server.
Для примера возьмем модуль
[wg\_push\_sender](https://github.com/wgnet/wg_push/blob/master/src/wg_push_sender.erl),
из
[библиотеки wg_push](https://github.com/wgnet/wg_push/),
которая используется для отправки сообщений на iOS устройства через
Apple Push Notification Service.


## behavior(gen_server)

TODO что такое behavior и callback


## инициализация

Все начинается с функции **start\_link/0**:

```erlang
start_link() ->
    gen_server:start_link({local, ?MODULE}, ?MODULE, [], []).
```

Здесь мы просим gen\_server запустить новый поток.

Макрос **?MODULE** разворачивается в имя текущего модуля.
Можно было написать:
```erlang
gen_server:start_link({local, wg_push_sender}, wg_push_sender, [], []).
```
получится тоже самое.

Первый аргумент **{local, ?MODULE}** -- это имя, под которым нужно
зарегистрировать поток.  Ну это если мы хотим обращаться к нашему
серверу по имени. Иначе вызываем gen\_server:start\_link/3, и
созданный поток не будет регистрироваться.

Второй аргумент **?MODULE** -- это имя модуля, callback-функции
которого будет вызывать gen\_server.

Третий аргумент -- это набор параметров, которые нужны при инициализации.
В нашем случае никакие не нужны.

Четверный аргумент -- настройки поведения gen\_server. Они довольно специфичны,
и необходимость что-то в них менять не возникает. Но загляните в документацию,
это полезно :)


TODO init/1

TODO record #state

TODO картинка, 4 части ген-сервера.

специальные потоки, модуль sys

## gen_server:call

TODO картинка, 4 части ген-сервера.
**call/handle_call**


## gen_server:cast

TODO картинка, 4 части ген-сервера.
**cast/handle_cast**


## другие callbacks

**message/handle_info**
TODO

**terminate**
TODO

**code_change**
TODO


## Отложенная инициализация

Вызов init блокирует родительский поток, причем с timeout = infinity
по умолчанию. Желательно оставлять эту функцию легковесной и
возвращать управление родителю как можно быстрее.

Если инициализация сервера требует долгих действий, то такие вещи
лучше делать отложено.

```
init(Args) ->
    State = ...
    self() ! heavy_init,
    {ok, State}.

handle_info(heavy_init, State) ->
    NewState = ...
    {noreply, NewState};
```

Устанавливать соединение с базой данных, запрашивать какие-то данные из внешнего
источника, создавать большие объекты в памяти -- все это стоит делать отложено.


## сравнение с ООП


## Deadlock на gen_server:call

С этим сталкивается почти каждый новичок в Erlang. И я тож столкнулся.

Нельзя делать gen\_server:call на самого себя внутри handle\_call.
Бывают более сложные варианты, когда из handle\_call вызвается какая-то функция,
и уже в ней, или где-то в цепочке вызовов gen\_server:call.

TODO объяснить, почему нельзя

TODO вот в этом нюансе аналогия с ООП хромает
