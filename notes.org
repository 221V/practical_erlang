* ets
В теме по ets затронуть read/write concurrency

OTP in Action
2.14 ETS tables

если юзать в консоли, и ошибка, процесс консоли падает и перезапускается
а ets теряется. Поэтому в консоли юзать не удобно, приходится аккуратно следить за опечатками
лучше пробовать сразу в модуле.

* string, binary, unicode
пусть данные остаются в binary, если это возможно (если их нужно просто передавать или хранить)
если нужно что-то делать с контентом, тогда unicode:characters_to_list
но не binary_to_list

When matching strings, the following is a valid pattern:
f("prefix" ++ Str) -> ...
This is syntactic sugar for the equivalent, but harder to read
f([$p,$r,$e,$f,$i,$x | Str]) -> ...

We’ll finish this section with a short discussion of the history of strings in the Erlang system.
цезарини, 27-я страница

* eunit
генераторы тестов. Неплохо, но есть проблемы:
- при возникновении ошибки непонятен источник
- отладка через io:format не работает
я предпочитаю оставить обычные тест кейзы, а общий код вынести в функцию
Quick Check -- неизученная тема, а надо бы знать.

* json
Сложно модифицировать сложные вложенные JSON объекты.
библиотека ej
в хаскеле есть какие-то линзы, что за они? Это не про это?
в LYH есть именно про это: перемещение по сложным структурам данных и их модификация. Перечитать, вспомнить.

* Супервизоры
рассмотреть разные стратегии
в т.ч. обязательно создание новых воркеров в рантайме
http://petabridge.com/blog/how-actors-recover-from-failure-hierarchy-and-supervision/

* Про cowboy
cowboy_req все время возвращает Req, и приходится делать
{Res, Req1} =
{_, Req2} =
и т.д., что не удобно
В cowboy 2 это пофиксили
В cowboy 0.x-1.0 это часто можно игнорировать, если Req реально не меняется.
А для этого нужно смотреть сорцы.
Примеры, где Req меняется, где нет.

httpc, lhttpc, exponential backoff

можно использовать крестики-нолики из 4-го урока
сделать игру для 2х пользователей на веб-сокетах

про веб-сокеты по-простому
http://habrahabr.ru/post/79038/

* dialyzer
у Армстронга 9-я глава про типы

* процессы
генерируем много процессов, даем каждому задание
каждый выдает ответ после рандомной задержки,
наблюдаем, как ответы приходят в хаотичном порядке.

Хорошо бы построить на этой базе какое-нибудь интересное практическое задание.

* mysql, postgresql
про erma, конечно
пару слов про ORM, ChicagoBoss

* errors
http://learnyousomeerlang.com/errors-and-exceptions#not-so-fast

Функция **dict:fetch/2** возвращает значение, если ключ найден. Или бросает
исключение, если такого ключа нет.  Функция **dict:find/2** возвращает
кортеж {ok, Val}, если ключ найден, или атом error, если ключа нет.

Как видим, у нас есть два разных подхода к ситуации, когда ключ не
найден.  Почему так, и какой подход в какой ситуации нужно
использовать, мы выясним на одном из последующих уроков, когда будем
изучать обработку ошибок.


* продвинутый курс (2-ю часть) начать с истории эрланга
  на фоне истории программирования:
  ассемблер, функциональные языки (Lisp, ML, OCaml)
  развитие железа, мейнстримовые языки (C, C++, Java, C#, Python)
  разложить на одной шкале времени, как они соотносятся друг с другом
  Можно начать с теории массового обслуживания.
  Ericson, PLEX

* Курсовая работа
  Игра Konquer
  Что-нибудь из распределенных алгоритмов. Типа выбор мастера (хотя конкретно это было тестовым заданием в Эхо, и не стоит им мешать :)
  Графовая база данных

* ssl, apns, gcm
В erlang-questions появилась тема, где обсуждается чрезмерный расход памяти при использовании SSL.
В этом треде увидел неожиданные для себя советы:
http://erlang.org/pipermail/erlang-questions/2015-February/083511.html
http://erlang.org/pipermail/erlang-questions/2015-February/083521.html
Alexander Shorin
Да, сталкивался и не раз. Рекомендация правильная, особенно если не
хочется внезапных приключений на пустом месте.
