* eunit
генераторы тестов. Неплохо, но есть проблемы:
- при возникновении ошибки непонятен источник
- отладка через io:format не работает
я предпочитаю оставить обычные тест кейзы, а общий код вынести в функцию
Quick Check -- неизученная тема, а надо бы знать.

* json
Сложно модифицировать сложные вложенные JSON объекты.
библиотека ej
в хаскеле есть какие-то линзы, что за они? Это не про это?
в LYH есть именно про это: перемещение по сложным структурам данных и их модификация. Перечитать, вспомнить.

* Супервизоры
рассмотреть разные стратегии
в т.ч. обязательно создание новых воркеров в рантайме
http://petabridge.com/blog/how-actors-recover-from-failure-hierarchy-and-supervision/

* Про cowboy
cowboy_req все время возвращает Req, и приходится делать
{Res, Req1} =
{_, Req2} =
и т.д., что не удобно
В cowboy 2 это пофиксили
В cowboy 0.x-1.0 это часто можно игнорировать, если Req реально не меняется.
А для этого нужно смотреть сорцы.
Примеры, где Req меняется, где нет.

httpc, lhttpc, exponential backoff

можно использовать крестики-нолики из 4-го урока
сделать игру для 2х пользователей на веб-сокетах

про веб-сокеты по-простому
http://habrahabr.ru/post/79038/

* dialyzer
у Армстронга 9-я глава про типы

* mysql, postgresql
про erma, конечно
пару слов про ORM, ChicagoBoss

* errors
http://learnyousomeerlang.com/errors-and-exceptions#not-so-fast

Функция **dict:fetch/2** возвращает значение, если ключ найден. Или бросает
исключение, если такого ключа нет.  Функция **dict:find/2** возвращает
кортеж {ok, Val}, если ключ найден, или атом error, если ключа нет.

Как видим, у нас есть два разных подхода к ситуации, когда ключ не
найден.  Почему так, и какой подход в какой ситуации нужно
использовать, мы выясним на одном из последующих уроков, когда будем
изучать обработку ошибок.

Есть научное обоснование, см Erlang in Anger, вступление
И диссертация Армстронга

* продвинутый курс (2-ю часть) начать с истории эрланга
  на фоне истории программирования:
  ассемблер, функциональные языки (Lisp, ML, OCaml)
  развитие железа, мейнстримовые языки (C, C++, Java, C#, Python)
  разложить на одной шкале времени, как они соотносятся друг с другом
  Можно начать с теории массового обслуживания.
  Ericson, PLEX

* Курсовая работа
  Игра Konquer
  Что-нибудь из распределенных алгоритмов. Типа выбор мастера (хотя конкретно это было тестовым заданием в Эхо, и не стоит им мешать :)
  Графовая база данных

* ssl, apns, gcm
В erlang-questions появилась тема, где обсуждается чрезмерный расход памяти при использовании SSL.
В этом треде увидел неожиданные для себя советы:
http://erlang.org/pipermail/erlang-questions/2015-February/083511.html
http://erlang.org/pipermail/erlang-questions/2015-February/083521.html
Alexander Shorin
Да, сталкивался и не раз. Рекомендация правильная, особенно если не
хочется внезапных приключений на пустом месте.


* Erlang often challenges newcomers in several ways:
- functional programming in a mostly-pure environment
- distributed computing
- concurrency
- error handling through asynchronous monitors/links
- language syntax and semantics
- how to build large erlang systems: module composition, releases, configuration, deployment
- how to test Erlang programs which have the above distribution/concurrency traits
- learning the performance model of Erlang: what is fast, what is slow
- all of the OTP stack, its idioms, design choices and how it influences program architecture
