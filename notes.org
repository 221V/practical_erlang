* list

как так получается, что список меняется, оставаясь неизменным )

they follow naturally from the idea of referen-
tial transparency, which basically means that the value to which a name refers isn’t
allowed to change

OTP in Action
2.2.10 Understanding lists
appendix B Lists and referential transparency

++
--
алгоритмическая сложность этих операций

Стоимость операций:
    добавить в начало списка - 1
    добавить в конец списка - O(n)
    получить N-й элемент - O(n)
    конкатернация двух списков - O(n)


нужно нарисовать схемы:
- модификация памяти на месте (императивный подход)
- добавление к голове, переиспользование памяти (функциональный подход)
- полное копирование объекта

К слову, массив (array) в эрланге тоже есть.
это не тип данных, это модуль. Упомяну его тут, чтобы потом забыть и больше не вспоминать :)
Это не настоящие массивы, как в императивных языках. В них нет главной фишки массивов: доступа к любому элементу за константное время, и изменения любого элемента за константное время.
Более того любая модификация потребует полного копирования массива и, соответственно, времени O(n).
Поэтому эти массивы нигде не используются :)



linked list, tree -- связи в одном направлении, к ним подходит 2й вариант
двунаправленный list, graph -- связи в разных направлениях, придется делать полное копирование объекта

lists comprehention
Pythagorean Triplets, armstrong, page 75
Block Expressions, armstrong, page 129

самые ходовые функции из модуля lists

показать improper list
Могут быть правильные (proper) и неправильные (nonproper)
[1,2,3]
[1 | [2,3]]
[1,2 | [3]]
[1,2 | 3]
язык их позволяет
специально их никто не делает, но могут получиться случайно, и вызывать ошибки

* Pattern matching
in Erlang is used to:
- Assign values to variables
- Control the execution flow of programs
- Extract values from compound data types

* guards
что-то про них было в рассылке, надо почитать
типа ; не есть эквивалент orelse, а comma не есть полный эквивалент andalso
есть какие-то тонкие различия между ними
guards cannot call user-defined functions, since we want to
guarantee that they are side effect free and terminate.

* kv-структуры
Maps are associative collections of key-value pairs. The key can be any Erlang
term. In Perl and Ruby they are called hashes; in C++ and Java they are called
maps, in Lua they are called tables, and in Python they are called dictionaries.

maps to_json, from_json -- во как. Надо доку почитать, что ли )

* ets
В теме по ets затронуть read/write concurrency

OTP in Action
2.14 ETS tables

* string, binary, unicode
пусть данные остаются в binary, если это возможно (если их нужно просто передавать или хранить)
если нужно что-то делать с контентом, тогда unicode:characters_to_list
но не binary_to_list

* eunit
генераторы тестов. Неплохо, но есть проблемы:
- при возникновении ошибки непонятен источник
- отладка через io:format не работает
я предпочитаю оставить обычные тест кейзы, а общий код вынести в функцию


* json
Сложно модифицировать сложные вложенные JSON объекты.
библиотека ej
в хаскеле есть какие-то линзы, что за они? Это не про это?
в LYH есть именно про это: перемещение по сложным структурам данных и их модификация. Перечитать, вспомнить.

* Супервизоры
рассмотреть разные стратегии
в т.ч. обязательно создание новых воркеров в рантайме

* Про сопоставление с образом (pattern matching)
оператора присваивания нет, есть оператор сопоставления с образцом :)

* Про cowboy
cowboy_req все время возвращает Req, и приходится делать
{Res, Req1} =
{_, Req2} =
и т.д., что не удобно
В cowboy 2 это пофиксили
В cowboy 0.x-1.0 это часто можно игнорировать, если Req реально не меняется.
А для этого нужно смотреть сорцы.
Примеры, где Req меняется, где нет.


* dialyzer
у Армстронга 9-я глава про типы


* mysql, postgresql
про erma, конечно
пару слов про ORM, ChicagoBoss
