## Key-Value структуры данных, продолжение.

## maps

Все, описанные выше структуры данных: **proplists**, **dict**, **orddict**,
**gb_trees**, реализованы поверх списков и кортежей, то есть, средствами
самого языка эрланг.  Понятно, что эти реализации будут уступать по
эффективности аналогичным структурам в императивных языках.

В отличие от них, модуль [maps](http://www.erlang.org/doc/man/maps.html) реализован внутри виртуальной
машины, средствами языка С. Так что от него вполне можно ожидать
большей эффективности.

Модуль появился недавно, в 17-й версии эрланг. И не считается пока что
стабильным. Работа по нему еще идет, и в новых версиях **maps** будут
улучшаться.

Помимо функций модуля, есть еще синтаксический сахар, похожий на сахар
для **records**. Это похожесть вносит некоторую путаницу. Разработчики
думают, что **maps** являются улучшеной версией **records** и должны
их заменить. Это не так, **maps** являются улучшенной версией
**dict**, и должны заменить **dict** и **proplists**. А **records**
вообще не являются key-value структурой, и имеют совсем другое
применение.

Из-за их новизны, maps не описаны в книгах. Только у Фреда Хеберта
есть [отдельная глава](http://learnyousomeerlang.com/maps), добавленная позже в онлайн версию книги.
Но она отсутствует в бумажной версии.

Создание новой карты **maps:new/0**:

```erlang
1> M = maps:new().
 #{}
```
тоже самое с синтаксическим сахаром:

```erlang
3> M = #{key1 => "value 1", key2 => "value 2"}.
 #{key1 => "value 1",key2 => "value 2"}
```

Добавление новых и изменение существующих элементов **maps:put/3**:

```erlang
2> M2 = maps:put(key1, "value 1", M).
 #{key1 => "value 1"}
3> M3 = maps:put(key2, "value 2", M2).
 #{key1 => "value 1",key2 => "value 2"}
5> M4 = maps:put(key2, "new value", M3).
 #{key1 => "value 1",key2 => "new value"}
```

тоже самое с синтаксическим сахаром:

```erlang
1> M = #{key1 => "value 1", key2 => "value 2"}.
 #{key1 => "value 1",key2 => "value 2"}
2> M2 = M#{key3 => "value 3"}.
 #{key1 => "value 1",key2 => "value 2",key3 => "value 3"}
3> M3 = M2#{key3 => "new value"}.
 #{key1 => "value 1",key2 => "value 2",key3 => "new value"}
```

Изменение существующих элементов **maps:update/3**:

```erlang
6> M5 = maps:update(key1, "new value", M4).
 #{key1 => "new value",key2 => "value 2"}
7> M6 = maps:update(key777, "new value", M5).
** exception error: bad argument
     in function  maps:update/3
        called as maps:update(key777,"new value",#{key1 => "new value",key2 => "value 2"})
```

тоже самое с синтаксическим сахаром:

```erlang
1> M = #{key1 => "value 1", key2 => "value 2"}.
 #{key1 => "value 1",key2 => "value 2"}
2> M2 = M#{key1 := "new value"}.
 #{key1 => "new value",key2 => "value 2"}
3> M3 = M#{key77 := "new value"}.
** exception error: bad argument
     in function  maps:update/3
        called as maps:update(key77,"new value",#{key1 => "value 1",key2 => "value 2"})
     in call from erl_eval:'-expr/5-fun-0-'/2 (erl_eval.erl, line 255)
     in call from lists:foldl/3 (lists.erl, line 1261)
```

put и update можно делать одновременно:

```erlang
21> M4 = M#{key1 := "new value", key3 => "value 3"}.
 #{key1 => "new value",key2 => "value 2",key3 => "value 3"}
```

Как видим, изменять элемент можно и функцией put и функций update.
Но в случае, если ключ отсутствует, то put добавляет новый элемент,
а update бросает исключение.

Получение элемента по ключу **maps:find/2**, **maps:get/2**:

```erlang
8> maps:get(key1, M5).
"new value"
9> maps:get(key777, M5).
** exception error: bad_key
     in function  maps:get/2
        called as maps:get(key777,#{key1 => "new value",key2 => "value 2"})
10> maps:get(key777, M5, "default value").
"default value"
11> maps:find(key1, M5).
{ok,"new value"}
12> maps:find(key777, M5).
error
```

Опять две функции с разным поведением в случае отсутствия ключа.

Сахар работает частично.  Обращение по ключу не работает, но
извлечение значений с помощью сопоставления с образцом работает:

```erlang
1> M = #{key1 => "value 1", key2 => "value 2"}.
 #{key1 => "value 1",key2 => "value 2"}
2> M#{key1}.
* 3: syntax error before: '}'
3> #{key1 := Val} = M.
 #{key1 => "value 1",key2 => "value 2"}
4> Val.
"value 1"
```

Удаление элемента по ключу **maps:remove/2**:

```erlang
12> maps:remove(key1, M5).
 #{key2 => "value 2"}
13> maps:remove(key777, M5).
 #{key1 => "new value",key2 => "value 2"}
```

А здесь только одна функция. Ну модуль будет дорабатываться, возможно еще добавят :)

Помимо CRUD API еще есть функции высшего порядка **maps:map/2** и **maps:fold/3**.
Функции filter нету.

```erlang
1> M = #{key1 => "Bob", key2 => "Bill", key3 => "Helen"}.
 #{key1 => "Bob",key2 => "Bill",key3 => "Helen"}
2> maps:map(fun(K, V) -> string:to_upper(V) end, M).
 #{key1 => "BOB",key2 => "BILL",key3 => "HELEN"}
3> maps:fold(fun(K, V, Acc) -> [V | Acc] end, [], M).
["Helen","Bill","Bob"]
```

Еще есть полезная функция **maps:merge/2**, которая сливает две карты в одну:

```erlang
1> M1 = #{key1 => "Val 1", key2 => "Val 2"}.
 #{key1 => "Val 1",key2 => "Val 2"}
2> M2 = #{key2 => "Val 222", key3 => "Val 3"}.
 #{key2 => "Val 222",key3 => "Val 3"}
3> maps:merge(M1, M2).
 #{key1 => "Val 1",key2 => "Val 222",key3 => "Val 3"}
4> maps:merge(M2, M1).
 #{key1 => "Val 1",key2 => "Val 2",key3 => "Val 3"}
```

В случае, если обе карты имеют одинаковый ключ, то значение берется из
карты, идущей вторым аргументом.


## ETS таблицы

И, наконец, завершает тему KV-структур данных особо мощная магия.
Это не просто структура данных. ETS-таблицу можно рассматривать как базу
данных.  Она расчитана на хранение большого объема данных и быстрый
доступ к ним.

ETS таблицы можно поставить в один ряд с такими базами данных
как [Memcached](http://memcached.org/) и [Redis](http://redis.io/).
ETS даже лучше, потому что к ним не нужно обращаться о сети,
а данные хранятся прямо в памяти виртуальной машины.

ETS означает Erlang Term Storage. Они реализованы на С как часть
виртуальной машины, и очень эффективны по производительности.  Ради
этой эффективности пришлось пожертвовать некоторыми принципами языка.
Их реализация, это отдельный императивный мир внутри функционального
языка, с модифицируеми данными и разделяемой между процессами памятью.
Впрочем, эрланг-разработчик может не беспокоиться об особенностях их
реализации, а просто пользоваться ими.

ETS таблицы хранят кортежи произвольного размера, один из элементов
которых используется как ключ.  По умолчанию -- это первый. Но при
создании ETS можно указать другую позицию элемента-ключа.  И это нужно
делать, если мы будем хранить в таблице records, что часто бывает.

Начнем, как обычно, с создания таблицы и CRUD операций.

```erlang
1> MyEts = ets:new(my_ets, []).
16400
```

Мы создали таблицу с именем **my_ets** и настройками по умолчанию.
В ответ получили идентификатор таблицы.

Кстати, если мы создали ее прямо в консоли, то нужно быть осторожными.
Таблица связана с процессом, который ее создал. И она удаляется, если
родительский процесс завершается. А процесс консоли завершается и
стартует заново при любой ошибке. Так что, если при работе в консоли
допустить опечатку или какое-либо исключение, то таблица исчезнет.
Но это касается только учебных ситуаций.

### CRUD API

Добавлять можно один элемент, или сразу список элементов:

```erlang
2> ets:insert(MyEts, {1, "Bob", 25}).
true
3> ets:insert(MyEts, [{2, "Bill", 30}, {3, "Helen", 22}]).
true
```
**ets:lookup/2** всегда возвращает список значений, даже если значение
только одно. Таблицы разных типов могут иметь одно или больше значений
для данного ключа, а API для всех типов одинаковое.  Если значения
нет, возвращается пустой список:

```erlang
4> ets:lookup(MyEts, 1).
[{1,"Bob",25}]
5> ets:lookup(MyEts, 3).
[{3,"Helen",22}]
6> ets:lookup(MyEts, 4).
[]
```

Изменение значения тоже делается функцией **ets:insert/2**:

```erlang
7> ets:insert(MyEts, {3, "Helen A.", 21}).
true
8> ets:lookup(MyEts, 3).
[{3,"Helen A.",21}]
```
Ну а удаление функцией **ets:delete/2**:

```erlang
9> ets:delete(MyEts, 2).
true
10> ets:lookup(MyEts, 2).
[]
```erlang

CRUD API довольно простое. В отличие от других модулей, тут всего 3 функции:
**ets:insert/2**, **ets:lookup/2**, **ets:delete/2**.


### Настройки таблицы

Первая настройка, которая нас интересует -- тип таблицы.
Есть 4 типа:

 - set -- все ключи должны быть уникальны;
 - ordered\_set -- ключи должны быть уникальны, и кортежи хранятся в сортированном виде;
 - bag -- разрешаются кортежи с одинаковыми ключами, но в целом кортежи должны быть разными;
 - duplicate\_bag -- разрешаются идентичные кортежи.

Тип таблицы по умолчанию -- set.

Далее, можно указать тип доступа к таблице:

 - public -- любой процесс может писать в таблицу и читать из нее;
 - protected -- любой процесс может читать из таблицы, но писать в нее может только процесс-владелец;
 - private -- только процесс-владелец может читать и писать.

Тип доступа по умолчанию -- protected.

Настройка, которая указывает позицию ключа в кортеже: {keypos, K}.
Вот так создается таблица, в которой планируется хранить records:

```erlang
MyEts = ets:new(my_ets, [set, private, {keypos, 2}]).
```

Есть и другие настройки, но для начала достаточно знать эти.


### Обход таблицы

Кроме получения значения по ключу, ETS-таблицы предоставляют и другие
варианты доступа к данным.  Один из вариантов -- последовательный
обход таблицы от начала к концу, или от конца к началу.

```erlang
1> T = ets:new(my_ets, []).
16400
2> ets:insert(T, [{1,"Bob",25}, {2, "Bill", 18}, {3, "Helen", 20}, {4, "Kate", 25}]).
true
3> Key1 = ets:first(T).
3
4> Key2 = ets:next(T, Key1).
1
5> Key3 = ets:next(T, Key2).
4
6> Key4 = ets:next(T, Key3).
2
7> Key5 = ets:next(T, Key4).
'$end_of_table'
8> K1 = ets:last(T).
3
9> K2 = ets:prev(T, K1).
1
10> K3 = ets:prev(T, K2).
4
11> K4 = ets:prev(T, K3).
2
12> K5 = ets:prev(T, K4).
'$end_of_table'
```

Вызовы first/1, next/2 или last/1, prev/2 возвращают ключи либо атом
'$end\_of\_table', когда достигнут конец таблицы.

Еще есть функция **ets:tab2list/1**, которая возвращает список всех
кортежей, хранящихся в таблице. Однако учитывая, что таблицы могут
содержать очень большой объем данных, разумнее использовать
first/next или last/prev.


### Выбор объектов по шаблону

Наконец, мы подходим к самым клевым фичам ETS :)

Хорошая новость -- мы можем использовать сопоставление с образцом
(pattern matching), чтобы выбирать нужные данные из таблицы.
Плохая новость -- синтаксис шаблонов отличается от обычного.

Тут есть два варианта: простые шаблоны с ограниченными возможностями,
которые используются в **ets:match/2**; и сложные шаблоны с широкими
возможностями, которые используются в **ets:select/2**.

#### Начнем с ets:match/2

Для начала создадим таблицу:

```erlang
1> T = ets:new(my_ets, []).
16400
2> ets:insert(T, [{1, "Bob", male}, {2, "Helen", female}, {3, "Bill", male}, {4, "Kate", female}]).
true
```

Шаблон представляет собой кортеж. Он содержит либо атомы вида
**'$1'**, **'$2'**, **'$3'**, либо конкретные значения. Атомы
обозначают поля, которые мы хотим извлечь из кортежей.  А значения
должны совпасть с данными в таблице:

```erlang
3> ets:match(T, {'$1', '$2', male}).
[[1,"Bob"],[3,"Bill"]]
4> ets:match(T, {'$1', '$2', female}).
[[2,"Helen"],[4,"Kate"]]
```

Здесь с помощью шаблона **{'$1', '$2', male}** извлекаем Id и имя
пользователя, а атомом **male** ограничиваем выборку. Аналогично
действует второй шаблон.

Еще можно использовать атом **'_'**, который совпадает с любым значением:

```erlang
5> ets:match(T, {'$2', '$1', '_'}).
[["Helen",2],["Kate",4],["Bob",1],["Bill",3]]
```
Шаблон **{'$2', '$1', '_'}** совпадет со всеми значениями в таблице.
Обратите внимание, что мы сперва указали '$2', а затем '$1'.
И в результате получили на первом месте имя, на втором Id.

Если мы хотим извлечь не отдельные поля из кортежей, а кортежи
целиком, то используем **ets:match_object/2**:

```erlang
6> ets:match_object(T, {'$1', '_', male}).
[{1,"Bob",male},{3,"Bill",male}]
```

Еще есть функция **ets:match_delete/2**, которая удаляет из таблицы
элементы, совпавшие с шаблоном.


#### Рассмотрим ets:select/2

Эта функция использует гораздо более сложные шаблоны. Это даже не
шаблоны, а отдельный язык со своим синтаксисом. Язык называется
**спецификация совпадения** (match specification).

Плохая новость -- на этом языке очень неудобно читать и
писать. Хорошая новость -- этого не нужно делать, потому что есть
синтаксический сахар.

Сперва разберем шаблон как он есть. Пример взят из книги Фреда Хеберта.

```erlang
[
{{'$1','$2',<<1>>,'$3','$4'},
[{'andalso',{'>','$4',150},{'<','$4',500}},
{'orelse',{'==','$2',meat},{'==','$2',dairy}}],
['$1']},
{{'$1','$2',<<1>>,'$3','$4'},
[{'<','$3',4.0},{is_float,'$3'}],
['$1']}
]
```

Здесь список из двух шаблонов. Разберем каждый из них по частям.

Первая часть называется базовый шаблон (Initial Pattern). Он такой же,
какой используется в ets:match.

```erlang
{'$1','$2',<<1>>,'$3','$4'}
```

Мы ищем совпадение с кортежем из 5-ти элементов.  В этом кортеже мы
связываем 1-й, 2-й, 4-й, и 5-й элементы с переменными '$1', '$2' и
т.д. А 3-й элемент должен иметь значение <<1>>.

Вторая часть -- гарды.

```erlang
[{'andalso',{'>','$4',150},{'<','$4',500}},
{'orelse',{'==','$2',meat},{'==','$2',dairy}}]
```

Те, кто знаком с языком Lisp сразу поняли этот синтаксис.  Для
остальных требуется пояснение.  Здесь используется префиксная
нотация. Вместо привычного **аргумент1, операция, аргумент2**, пишется
**операция, аргумент1, аргумент2**.

В данном случае гарды читаются так:
Переменная '$4' должна быть больше 150 и меньше 500,
переменная '$2' должна иметь значение meat либо dairy.


```erlang
['$1']
```

Третья часть -- это значение, которое мы хотим вернуть. В данном
случае значение переменной '$1'.

```erlang
{{'$1','$2',<<1>>,'$3','$4'},
[{'<','$3',4.0},{is_float,'$3'}],
['$1']}
```

Второй шаблон имеет такую же базу, такое же возвращаемое значение, но
другие гарды. Переменная '$3' должна быть float и иметь значение
меньше 4.0.

Любители List могут пользоваться этим языком, а мы рассмотрим
синтаксический сахар. Шаблон можно записать в синтаксисе, очень похожем
на обычный эрланг.

```erlang
fun({Food, Type, <<1>>, Price, Calories})
    when Calories > 150 andalso Calories < 500,
         Type == meat orelse Type == dairy;
         Price < 4.00, is_float(Price) ->
    Food
end.
```

Этот код выглядит как анонимная функция, которая принимает кортеж из
5-ти элементов, применяет гарды, и возвращает значение. На самом деле
это не функция, а шаблон, который с помощью **ets:fun2ms/1** (fun to
match specification) преобразуется в то, что мы разбирали выше.

Как видно, этот код читать гораздо легче. Во-первых, потому что
переменные именованы, а не просто циферки. Во-вторых потому, что это
обычный синтаксис Эрланг.

Теперь мы можем перейти к примерам:

TODO: примеры
код в модуле
{1, "Bob", 25, male}
вернуть отдельные поля
вернуть кортеж целиком

```erlang
ets:fun2ms(fun(X) when X > 4 -> X end).
```

**ets:fun2ms/1** работает в консоли. Но чтобы использовать ее в модуле
нужно подключить заголовочный файл ms_transform.hrl:

```erlang
-include_lib("stdlib/include/ms_transform.hrl").
```


### Что еще нужно знать о ETS таблицах
TODO

Память:
не подвергаются сборке мусора
удалять данные из них нужно явно
удаляется вся таблица при завершении процесса-родителя

An ETS table is said to be owned by the
process that created it—when that process dies or when ets:delete is
called, then the table is deleted.

если юзать в консоли, и ошибка, процесс консоли падает и перезапускается
а ets теряется. Поэтому в консоли юзать не удобно, приходится аккуратно следить за опечатками
лучше пробовать сразу в модуле.


Особенности concurrency:

Добавление, удаление, обновление одиночного объекта (и списка объектов) атомарно и изолировано.

Атомарно, это значит транзация либо завершится успешно, либо будет отменена.
Изолировано, это значит, что во время действия транзации ее промежуточные
результаты не будут видны другим процессам.

обходе таблицы с помощью first/next и при выборке с помощью match или select
гарантируется, что каждый уже существующий в таблице кортеж будет рассмотрен, и только один раз.
Если за время обхода или выборки будут вставлены новые кортежи, то они могут
быть рассмотрены, а могут быть пропущены. Для них гарантий нет.


### dets, mnesia
TODO

dest добавляет хранение данных на диске
Disk ETS

Data stored in DETS tables is persistent and should survive an entire system crash.
(правда восстановление таблицы после краша может занять долгое время)
Since the repair can take a long time, it’s important to
close them properly before finishing your application.

DETS files have a maximum size of 2GB.

mnesia -- распределенное KV хранилище с поддержкой транзакций.
support for sharding, transactions, and distribution.
Ее никто не использует, кроме Ericsson. Предпочитают другие базы данных, например Riak.
