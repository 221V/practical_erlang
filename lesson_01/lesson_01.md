# Эрланг на практике, урок №1.

TODO:

- написать всю теорию
- сделать все TODO по тексту
- спеллчек

- подготовить презентацию
  - последний слайд: summary, о чем рассказывалось в уроке

- записать видео

- подготовить quiz

- подготовить упраженения
  - есть упражнения в книге Цезарини
  - этюды для эрланг
  - книги по хаскелю

- в syllabus.org поправить название и описание урока

- выложить все на hexlet.io


## Вступление

Всем привет :)

Это первый урок курса "Erlang на практике". И раз вы здесь, значит вы,
вероятно, слышали о существовании такого языка программирования.
И, наверное, хотите научиться программировать на нем.

С одной стороны, изучить эрланг довольно легко. Сам язык простой, есть
несколько хороших книг про него -- бери да учи.

Может быть вы от кого-то слышали, что эрланг можно освоить за 2
недели, и потом можно сразу писать код в реальных проектах.  Это почти
правда. Действительно можно изучить эрланг по книге за 2 недели.
И, действительно, после этого можно писать код в реальных проектах.
Но это если вы попали в команду опытных эрланг-разработчиков и пишите код
под их присмотром :)

Увы, не всем повезло попасть в такую команду. И есть некоторый разрыв
между изучением языка по книгам и реальной работой.  Цель моего курса --
закрыть этот разрыв.

Курс не заменяет книги и не отменяет необходимость их читать.  Я не
дам всю теорию, которую нужно знать, и не очень много внимания уделю
основам языка.  Во-первых, если задаться целью полностью изложить всю
теорию, то курс стал бы слишком большой. А он и так не маленький.
Во-вторых, по эрлангу есть хорошие книги, написанные хорошими
авторами. И мне нет смысла состязаться с ними по глубине знаний и
остроте таланта, я проиграю :)

Вместо этого мы сосредоточимся на том, чего нет в книгах -- на
практике.  Будет много упражнений, несколько небольших проектов, и
большой проект в конце курса.  Вы будете писать код и получать навыки,
необходимые в реальной работе.

Паралельно с изучением курса вам нужно будет прочитать одну из рекомендованных книг.


### Изучай Erlang во имя добра!
Фред Хеберт

Переведенная на русский язык:
http://www.ozon.ru/context/detail/id/28953563/

В оригинале:
Learn You Some Erlang for Great Good!: A Beginner's Guide
Fred Hebert
http://www.amazon.com/Learn-Some-Erlang-Great-Good/dp/1593274351/

Бесплатная html версия: http://learnyousomeerlang.com/

Пожалуй, лучшая книга по эрланг. Фред сделал просто эпичный труд, спасибо ему за это.
Написано легко, весело, понятно, и про все, про что только можно было написать.
(Из-за этого книга получилась очень большая, и читать ее придется долго :)


### Программирование в Erlang
Франческо Чезарини, Симон Томпсон

Переведенная на русский язык:
http://www.ozon.ru/context/detail/id/30671701/

В оригинале:
Erlang Programming
Francesco Cesarini, Simon Thompson
http://www.amazon.com/Erlang-Programming-Francesco-Cesarini/dp/0596518188/

Четкое, последовательное, понятное изложение. Хороший учебник.
Несколько сухая, академичная, без шуточек, как у Фреда.


### Programming Erlang: Software for a Concurrent World (Pragmatic Programmers)
Joe Armstrong

http://www.amazon.com/Programming-Erlang-Concurrent-Pragmatic-Programmers/dp/193778553X/

Автор -- один из создателей языка эрланг. Написано не так сухо, как у Чезарини, более живо, литературно.
Немного страдает последовательность изложения, начальные темы идут в довольно странном порядке.
Но все равно все мы любим Джо Армстронга :)


### Erlang and OTP in Action
Martin Logan, Eric Merritt, Richard Carlsson

http://www.amazon.com/Erlang-OTP-Action-Martin-Logan/dp/1933988789/

Тоже неплохой способ изучить эрланг. Тут основы языка даются довольно кратко, а предлагается
наблюдать за разработкой проекта, от начальной идеи, через несколько инкрементальных улучшений,
до построения довольно сложной системы.

Можете начинать с любой из этих 4-х книг. Или прочитать 2-3. Они не пересекаются полностью,
у каждой есть свои темы и свои фишки.


## Чем хорош эрланг

Наверняка вы уже наслышаны о легковесных потоках, передаче сообщений,
устойчивости к ошибкам и о горячем обновлении кода.

А если не слышали, то прочитаете об этом на первых страницах вышеуказанных книг,
(или в моем блоге http://yzh44yzh.by/ :)

Но, все-таки, кратко:

Виртуальная машина эрланг имеет свою реализацию многопоточности, свои
планировщики, работающие поверх процессов операционной системы, и
умеющие создавать и управлять десятками и сотнями тысяч потоков.
Новый поток стартует за *3-5 микросекунд* (не милисекунд, а микросекунд)
и занимает около *2.5 Кб* памяти.

У каждого потока своя область памяти и свой сборщик мусора.  Нету
разделяемой между потоками памяти, которой нужно управлять с помощью
блокировок, и нету ошибок типа *dead lock* и *race condition*.
(На самом деле не все так просто, но на начальных этапах изучения языка
можно считать, что этого нет :)

Потоки обмениваются сообщениями друг с другом. При этом данные копируются
из памяти одного потока в память другого потока. Таким образом, поток никак
не может испортить чужую память. И это значительно упрощает разработку
многопоточных приложений.

Эрланг предлагает средства (примитивы языка и архитектурные паттерны),
значительно повышающие устойчивость к ошибкам. Это не значит, что ваш код
прям сразу мегаусточив. Это значит, что у вас есть хорошие средства, чтобы
добиться этого, приложив свои знания и опыт :)

Ну и горячее обновление кода. Оно есть, оно работает, и вам не нужно
останавливать сервер, чтобы обновить его. На самом деле далеко не все
пользуются этой фичей, и она полезнее в процессе разработки на компьютере
программиста, чем на сервере.


## Инструменты и окружение

Курс практический. Это значит, что придется писать, отлаживать и запускать код.

TODO
emacs, intellij idea
hexlet web ide


## Работа в erlang-shell

TODO: В видео можно показать. В теории буквально 2 слова. Quiz можно сделать.

Запуск с разными аргументами, какие актуальны
Остановка разными способами

запуск erl выход C-G q help()

b() – display all variable bindings f() – forget all variable bindings f(X) – forget the binding of variable X c(File) – compile and load code in <File> l(Module) – load or reload module flush() – flush any messages sent to the shell q() – quit - shorthand for init:stop()

i() – information about the system i(X,Y,Z) – information about pid <X,Y,Z>Еще m() – which modules are loaded m(Mod) – information about module <Mod> memory() – memory allocation information regs() – information about registered processes

C-G User switch command –> h c [nn] - connect to job i [nn] - interrupt job k [nn] - kill job j - list all jobs s [shell] - start local shell r [node [shell]] - start remote shell q - quit erlang ? | h - this message


## типы данных
TODO пару слов, какие вообще типы есть

### integer
TODO
small int 1 байт
int 1 word (4/8 bytes)
small bignum 1 байт заголовок
large bignum 4 байта заголовок

the number of digits that can be represented
in an integer is limited only by available memory.

1> 2#101010.
42
2> 8#0677.
447
3> 16#AE.
174

### float
TODO

IEEE 754
http://en.wikipedia.org/wiki/IEEE_floating_point

TODO показать в консоли пару примеров с ошибками округления

Erlang uses 64-bit IEEE 754-1985 floats

1.0 3.14159 -2.3e+6 23.56E-27

http://habrahabr.ru/post/112953/
Что нужно знать про арифметику с плавающей запятой

### atom
TODO
константное значение ‘Atom in single quote’

довольно типичный тип данных для функциональных языков
используются как эффективные по памяти и производительности имена сущностей
для них определена только операция сравнения

в большинстве случаев мы можем использовать как имя любой term (в ets например)
в некоторых -- только атом (для регистрации процессов, например)

Аналог в Java – enum enum Season { WINTER, SPRING, SUMMER, AUTUMN }

Аналог в C – define define WIDTH 80


делают код более понятным:

{ok, Value}
{error, Reason}
{user, "Bob", 22}
-type(my_bool() :: true | false | undefined).

глобальная область видимости (в пределах ноды)
хранятся в таблице атомов, занимают 4 или 8 байт, эта память не освобождается (4 bytes/atom in a 32-bit system, 8 bytes/atom in a 64-bit system).

нет встроенного в язык типа boolean, есть атомы true false, которые по соглашению считаются boolean
операции сравнения ==, <, > и т.д. реализованы в языке так, что возвращают эти атомы

boolean() = true | false.
но из функций можно возвращать и более мнемоничные атомы
ok | error
Value | not_found
и т.д.

не генерировать их динамически
list_to_atom опасно
list_to_existing_atom -- ок



### tuple
TODO

group a fixed number of items into a single entity
размер известен на стадии компиляции и не меняется

аналог struct в C (и внутри виртуальной машины именно так и представлен)

Элементы обычно извлекаются паттерн матчингом, но есть функция element, иногда удобно использовать ее.

Кортеж – обычная структура данных для функциональных языков, но почти не встречается в языках императивных. Подобно списку, это набор значений, доступных по их позиции. Но кортеж имеет фиксированную длинну, не больше и не меньше. Такая структура может показаться странной, но она очень удобна в pattern matching. И поэтому используется повсемесно, так же как и сам pattern matching.

В императивных языках обычно используют словари (в Java, наример, варианты Map), там где в функциональных используют кортежи. Кортежи проигрывают в ясности значений, зато сильно выигрывают в лаконичности кода. Ну а ясность значений можно подчеркнуть там, где это необходимо

Для этого первым элементом обычно ставят атом, указывающий на суть данных:

{point, 10, 15}
{rect, {point, 10, 10}, {point, 20, 20}}
{user, 22, "Bob"}
{direction, up}
{error, "user not found"}

Это называется тэгированый кортеж. tagged tuple

Но все-таки кортежи сами по себе хороши для небольших объектов, на 2-4 поля. Если нужно больше полей, то тут на помощь приходит record

###  list
TODO

рабочая лошадка всех функциональных языков. Основная структура данных. А в некоторых языках (в Lisp) – вообще единственная структура данных. Представляет собой однонаправленный связанный список.

Стоимость операций:

    добавить в начало списка - 1
    добавить в конец списка - O(n)
    получить N-й элемент - O(n)
    конкатернация двух списков - O(n)

Поэтому всегда работают с началом списка. А конкатернации можно и нужно избегать, используя вместо нее io_list.

Могут быть какой угодно вложенности

[1,2,[1,2,3],3]

Могут быть правильные (proper) и неправильные (nonproper)

[1,2,3]
[1 | [2,3]]
[1,2 | [3]]
[1,2 | 3]

Примеры сложных типов данных из кортежей и списков.

### array
TODO

Это не настоящие массивы, как в императивных языках. В них нет главной фишки массивов: доступа к любому элементу за константное время, и изменения любого элемента за константное время.

Более того любая модификация потребует полного копирования массива и, соответственно, времени O(n).

Поэтому эти массивы нигде не используются :)

### record
TODO

Представляет собой синтаксический сахар, добавленный в язык позже. На этапе компиляции превращается в обычный кортеж и имена полей теряются. Зато принципы работы с ними вполне аналогичны работе со словорями в других языках.

-record(user, {id, name, age}). % {user, undefined, undefined, undefined}
-record(user, {id = 0, name = "", age = 0}). % {user, 0, "", 0}
-record(user, {
    id = 0 :: user_id(),
    name = "" :: string(),
    age = 0 :: age()
    }).

User = #user{}
User = #user{id = 5}
User = #user{id = 5, name = "Bob", age = 24}
UserId = User#user.id
UserName = User#user.name
User2 = User#user{id = 7}.

Функции для работы с записями из консоли: rd(R,D) – define a record rl() – display all record information rr(File) – read record information from File (wildcards allowed)

2> rd(user, {id, name, age}).
user
3> rl().
-record(user,{id,name,age}).
ok
4> {user, 5, "Bob", 23}.
#user{id = 5,name = "Bob",age = 23}
5> Bob = #user{id = 6, name = "Bob"}.
#user{id = 6,name = "Bob",age = undefined}
6> Bill = Bob#user{name = "Bill"}.
#user{id = 6,name = "Bill",age = undefined}
7> Bob#user.id.

### прочие типы
TODO

Pid, port, and reference (ref)

A port is much like a process, except that it can also communicate with the world out-
side Erlang (and can’t do much else—in particular, it can’t run any code)

fun

number < atom < reference < fun < port < pid < tuple (and record) < map < list < binary
