# Эрланг на практике, урок №1. Вступление, типы данных.

TODO:

- написать всю теорию
- сделать все TODO по тексту
- спеллчек

- подготовить презентацию
  - последний слайд: summary, о чем рассказывалось в уроке

- записать видео

- подготовить quiz

- подготовить упраженения
  - есть упражнения в книге Цезарини
  - этюды для эрланг
  - книги по хаскелю

- в syllabus.org поправить название и описание урока

- выложить все на hexlet.io


## Вступление

Всем привет :)

Это первый урок курса "Erlang на практике". И раз вы здесь, значит вы,
вероятно, слышали о существовании такого языка программирования.
И, наверное, хотите научиться программировать на нем.

С одной стороны, изучить эрланг довольно легко. Сам язык простой, есть
несколько хороших книг про него -- бери да учи.

Может быть вы от кого-то слышали, что эрланг можно освоить за 2
недели, и потом можно сразу писать код в реальных проектах.  Это почти
правда. Действительно можно изучить эрланг по книге за 2 недели.
И, действительно, после этого можно писать код в реальных проектах.
Но это если вы попали в команду опытных эрланг-разработчиков и пишите код
под их присмотром :)

Увы, не всем повезло попасть в такую команду. И есть некоторый разрыв
между изучением языка по книгам и реальной работой.  Цель моего курса --
закрыть этот разрыв.

Курс не заменяет книги и не отменяет необходимость их читать.  Я не
дам всю теорию, которую нужно знать, и не очень много внимания уделю
основам языка.  Во-первых, если задаться целью полностью изложить всю
теорию, то курс стал бы слишком большой. А он и так не маленький.
Во-вторых, по эрлангу есть хорошие книги, написанные хорошими
авторами. И мне нет смысла состязаться с ними по глубине знаний и
остроте таланта, я проиграю :)

Вместо этого мы сосредоточимся на том, чего нет в книгах -- на
практике.  Будет много упражнений, несколько небольших проектов, и
большой проект в конце курса.  Вы будете писать код и получать навыки,
необходимые в реальной работе.

Паралельно с изучением курса вам нужно будет прочитать одну из рекомендованных книг.


### Изучай Erlang во имя добра!
Фред Хеберт

[Переведенная на русский язык](http://www.ozon.ru/context/detail/id/28953563/)

В оригинале:
[Learn You Some Erlang for Great Good!: A Beginner's Guide
Fred Hebert](http://www.amazon.com/Learn-Some-Erlang-Great-Good/dp/1593274351/)

[Бесплатная html версия](http://learnyousomeerlang.com/)

Пожалуй, лучшая книга по эрланг. Фред сделал просто эпичный труд, спасибо ему за это.
Написано легко, весело, понятно, и про все, про что только можно было написать.
(Из-за этого книга получилась очень большая, и читать ее придется долго :)


### Программирование в Erlang
Франческо Чезарини, Симон Томпсон

[Переведенная на русский язык](http://www.ozon.ru/context/detail/id/30671701/)

В оригинале:
[Erlang Programming
Francesco Cesarini, Simon Thompson](http://www.amazon.com/Erlang-Programming-Francesco-Cesarini/dp/0596518188/)

Четкое, последовательное, понятное изложение. Хороший учебник.
Несколько сухая, академичная, без шуточек, как у Фреда.


### Programming Erlang: Software for a Concurrent World (Pragmatic Programmers)
Joe Armstrong

[В оригинале](http://www.amazon.com/Programming-Erlang-Concurrent-Pragmatic-Programmers/dp/193778553X/)

Автор -- один из создателей языка эрланг. Написано не так сухо, как у Чезарини, более живо, литературно.
Немного страдает последовательность изложения, начальные темы идут в довольно странном порядке.
Но все равно все мы любим Джо Армстронга :)


### Erlang and OTP in Action
Martin Logan, Eric Merritt, Richard Carlsson

[В оригинале](http://www.amazon.com/Erlang-OTP-Action-Martin-Logan/dp/1933988789/)

Тоже неплохой способ изучить эрланг. Тут основы языка даются довольно кратко, а предлагается
наблюдать за разработкой проекта, от начальной идеи, через несколько инкрементальных улучшений,
до построения довольно сложной системы.

Можете начинать с любой из этих 4-х книг. Или прочитать 2-3. Они не пересекаются полностью,
у каждой есть свои темы и свои фишки.


## Чем хорош эрланг

Наверняка вы уже наслышаны о легковесных потоках, передаче сообщений,
устойчивости к ошибкам и о горячем обновлении кода.

А если не слышали, то прочитаете об этом на первых страницах вышеуказанных книг,
(или в моем блоге http://yzh44yzh.by/ :)

Но, все-таки, кратко:

Виртуальная машина эрланг имеет свою реализацию многопоточности, свои
планировщики, работающие поверх процессов операционной системы, и
умеющие создавать и управлять десятками и сотнями тысяч потоков.
Новый поток стартует за *3-5 микросекунд* (не милисекунд, а микросекунд)
и занимает около *2.5 Кб* памяти.

У каждого потока своя область памяти и свой сборщик мусора.  Нету
разделяемой между потоками памяти, которой нужно управлять с помощью
блокировок, и нету ошибок типа *dead lock* и *race condition*.
(На самом деле не все так просто, но на начальных этапах изучения языка
можно считать, что этого нет :)

Потоки обмениваются сообщениями друг с другом. При этом данные копируются
из памяти одного потока в память другого потока. Таким образом, поток никак
не может испортить чужую память. И это значительно упрощает разработку
многопоточных приложений.

Эрланг предлагает средства (примитивы языка и архитектурные паттерны),
значительно повышающие устойчивость к ошибкам. Это не значит, что ваш код
прям сразу мегаусточив. Это значит, что у вас есть хорошие средства, чтобы
добиться этого, приложив свои знания и опыт :)

Ну и горячее обновление кода. Оно есть, оно работает, и вам не нужно
останавливать сервер, чтобы обновить его. На самом деле далеко не все
пользуются этой фичей, и она полезнее в процессе разработки на компьютере
программиста, чем на сервере.


## Типы данных

Посмотрим, какие встроенные типы данных имеет эрланг.

Их не много, 11 штук. Но я бы все равно их классифицировал.
Это не официальная классификация, моя:
 - численные: integer, float;
 - атомы;
 - структуры: list, tuple, map;
 - идентификаторы: pid, port, reference;
 - функции;
 - binary;

Разумеется, на базе встроенных типов данных можно строить любое количество своих.
Но сначала познакомимся с базовыми.


### integer

Целое число со знаком. Диапазон значений не ограничен. Памяти
выделяется столько, сколько нужно, чтобы хранить значение. В
большинстве случаев это будет 1 машинное слово (4 байта на 32-х
разрядной платформе, 8 байт на 64-х разрядной). Если число большое, и
для его хранения не хватает машинного слова, то памяти выделяется
больше.

Это удобно для программиста, но не очень эффективно по производительности.
Поэтому для эрланга не характерны высокопроизводительные операции с числами.

Числа могут быть представлены в различных системах исчисления, что иногда удобно:

    1> 2#101010.
    42
    2> 8#0677.
    447
    3> 16#AE.
    174


### float

Число с плавающей точкой. Как и в большинстве других языков, реализованно по стандарту
[IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point).
Соответственно, занимает 8 байт памяти. Может быть представлено в разных видах.

    1> 2.5.
    2.5
    2> 3.14159.
    3.14159
    3> -2.3e+6.
    -2.3e6
    4> 23.56E-27.
    2.356e-26

И подвержено потере точности при вычислениях, точно так же, как и в других языках.

    5> 0.1 + 0.2.
    0.30000000000000004

Таков стандарт IEEE 754 :) Если вы вдруг не знаете, почему так
получилось, но хотите узнать, почитайте
["Что нужно знать про арифметику с плавающей запятой"](http://habrahabr.ru/post/112953/)


### atom

Вот тут уже сложнее объяснить. Атомы типичны для функциональных языков,
но не встречаются в языках императивных.

Это некие константные значения, которые можно сравнивать друг с другом
на предмет совпадения.  Собственно, сравнивать -- это единственное,
что с ними можно делать.

    1> Color1 = green.
    green
    2> Color2 = red.
    red
    3> Color3 = green.
    green
    4> Color1 == Color2.
    false
    5> Color1 == Color3.
    true

При этом они очень широко используются. Но не так, как в примере выше,
а в основном для "сопоставления с образцом" (pattern matching).  У нас
будет отдельный урок, посвященных этой теме.

Пока можно считать, что это некий аналог перечислений (enum),
хотя это не совсем точно.

В документации и во всех книгах авторы рассказывают, что атомы
храняться в специальной таблице в памяти и никогда не удаляются
оттуда. Поэтому их нельзя генерировать динамически.
*list_to_atom/1* опасен (не совсем очевидно, но *binary_to_term/1*
опасен таким же образом). А вот *list_to_existing_atom/1* безопасен.

Все-все эрланг разработчики это знают, но все равно иногда это
делают. Даже очень опытные.  И в один прекрасный момент у них падает
нода из-за исчерпания всей памяти ОС.  Ну вот, я предупредил, и вы
теперь тоже об этом знаете, и никогда не будете так делать :)

Атомы имеют глобальную область видимости (в пределах ноды) и занимают
1 машинное слово в памяти.

Интересно, что в эрланге нет типа данных *boolean*. А роль boolean
значений выполняют атомы *true* и *false*. Операции сравнения ==, <, >
и т.д. реализованы в языке так, что возвращают эти атомы.


### tuple

Еще один тип данных, который есть во всех функциональных языках, но
редко встречается в императивных.

TODO

group a fixed number of items into a single entity
размер известен на стадии компиляции и не меняется

аналог struct в C (и внутри виртуальной машины именно так и представлен)

Элементы обычно извлекаются паттерн матчингом, но есть функция element, иногда удобно использовать ее.

Кортеж – обычная структура данных для функциональных языков, но почти не встречается в языках императивных. Подобно списку, это набор значений, доступных по их позиции. Но кортеж имеет фиксированную длинну, не больше и не меньше. Такая структура может показаться странной, но она очень удобна в pattern matching. И поэтому используется повсемесно, так же как и сам pattern matching.

В императивных языках обычно используют словари (в Java, наример, варианты Map), там где в функциональных используют кортежи. Кортежи проигрывают в ясности значений, зато сильно выигрывают в лаконичности кода. Ну а ясность значений можно подчеркнуть там, где это необходимо

Для этого первым элементом обычно ставят атом, указывающий на суть данных:

{point, 10, 15}
{rect, {point, 10, 10}, {point, 20, 20}}
{user, 22, "Bob"}
{direction, up}
{error, "user not found"}

Это называется тэгированый кортеж. tagged tuple

Но все-таки кортежи сами по себе хороши для небольших объектов, на 2-4 поля. Если нужно больше полей, то тут на помощь приходит record

###  list
TODO

рабочая лошадка всех функциональных языков. Основная структура данных. А в некоторых языках (в Lisp) – вообще единственная структура данных. Представляет собой однонаправленный связанный список.

Стоимость операций:

    добавить в начало списка - 1
    добавить в конец списка - O(n)
    получить N-й элемент - O(n)
    конкатернация двух списков - O(n)

Поэтому всегда работают с началом списка. А конкатернации можно и нужно избегать, используя вместо нее io_list.

Могут быть какой угодно вложенности

[1,2,[1,2,3],3]

Могут быть правильные (proper) и неправильные (nonproper)

[1,2,3]
[1 | [2,3]]
[1,2 | [3]]
[1,2 | 3]

Примеры сложных типов данных из кортежей и списков.

### array
TODO

это не тип данных, это модуль. Упомяну его тут, чтобы потом забыть и больше не вспоминать :)

Это не настоящие массивы, как в императивных языках. В них нет главной фишки массивов: доступа к любому элементу за константное время, и изменения любого элемента за константное время.

Более того любая модификация потребует полного копирования массива и, соответственно, времени O(n).

Поэтому эти массивы нигде не используются :)

### record
TODO

Представляет собой синтаксический сахар, добавленный в язык позже. На этапе компиляции превращается в обычный кортеж и имена полей теряются. Зато принципы работы с ними вполне аналогичны работе со словорями в других языках.

-record(user, {id, name, age}). % {user, undefined, undefined, undefined}
-record(user, {id = 0, name = "", age = 0}). % {user, 0, "", 0}
-record(user, {
    id = 0 :: user_id(),
    name = "" :: string(),
    age = 0 :: age()
    }).

User = #user{}
User = #user{id = 5}
User = #user{id = 5, name = "Bob", age = 24}
UserId = User#user.id
UserName = User#user.name
User2 = User#user{id = 7}.

Функции для работы с записями из консоли: rd(R,D) – define a record rl() – display all record information rr(File) – read record information from File (wildcards allowed)

2> rd(user, {id, name, age}).
user
3> rl().
-record(user,{id,name,age}).
ok
4> {user, 5, "Bob", 23}.
#user{id = 5,name = "Bob",age = 23}
5> Bob = #user{id = 6, name = "Bob"}.
#user{id = 6,name = "Bob",age = undefined}
6> Bill = Bob#user{name = "Bill"}.
#user{id = 6,name = "Bill",age = undefined}
7> Bob#user.id.

### прочие типы
TODO

Pid, port, and reference (ref)

A port is much like a process, except that it can also communicate with the world out-
side Erlang (and can’t do much else—in particular, it can’t run any code)

fun

number < atom < reference < fun < port < pid < tuple (and record) < map < list < binary
