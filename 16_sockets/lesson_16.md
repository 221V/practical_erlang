- источники инфы:
  - официальные доки
  - Армстронг
  - Цезарини
  - Хеберт
  - erlang in anger
  - OTP in action


# Эрланг на практике. TCP и UDP сокеты

## UDP сокет

http://www.erlang.org/doc/man/gen_udp.html

Запустим 2 ноды, и пообщаемся по UDP между ними.

На 1й ноде откроем UDP на порту 2000:
```erlang
1> {ok, Socket} = gen_udp:open(2000, [binary, {active, true}]).
{ok,#Port<0.587>}
```

На 2й ноде откроем UDP на порту 2001:
```erlang
1> {ok, Socket} = gen_udp:open(2001, [binary, {active, true}]).
{ok,#Port<0.587>}
```

Пошлем сообщение с 1-й на 2-ю ноду:
```erlang
2> gen_udp:send(Socket, {127,0,0,1}, 2001, <<"Hello from 2000">>).
ok
```

На второй ноде убедимся, что сообщение пришло. И пошлем ответ:
```erlang
2> flush().
Shell got {udp,#Port<0.587>,{127,0,0,1},2000,<<"Hello from 2000">>}
ok
3> gen_udp:send(Socket, {127,0,0,1}, 2000, <<"Hello from 2001">>).
ok
```

На первой убедимся, что сообщение пришло:
```erlang
3> flush().
Shell got {udp,#Port<0.587>,{127,0,0,1},2001,<<"Hello from 2001">>}
ok
```


## Активный и пассивный режим сокета

И gen_udp, и gen_tcp, оба имеют одну важную настройку: режим работы с входящими данными.

Это может быть либо активный режим {active, true}, либо пассивный режим {active, false}.

В активном режиме входящие пакеты отправляются сообщениями потоку -- владельцу сокета.
И поток должен их получить с помощью receive и обработать.

Для udp сокета это сообщения вида:
{udp, Socket, IP, InPortNo, Packet}
мы их уже видели:
{udp,#Port<0.587>,{127,0,0,1},2001,<<"Hello from 2001">>}

Для tcp сокета аналогичные сообщения:
{tcp, Socket, Packet}

Активный режим прост в использовании, но опасен тем, что клиент может
завалить сообщениями поток и нарушить его работу. То есть, открывает возможности
для DDOS атак. Поэтому рекомендуется пассивный режим.

В пассивном режиме данные нужно забрать самому, вызовом
gen_udp:recv/3, gen_tcp:recv/3

```erlang
gen_udp:recv(Socket, Length, Timeout) ->
        {ok, {Address, Port, Packet}} | {error, Reason}

gen_tcp:recv(Socket, Length, Timeout) -> {ok, Packet} | {error, Reason}
```

Здесь мы указываем, сколько байт данных хотим прочитать из сокета. Если там есть
эти данные, то мы получаем их сразу. Если нет, то вызов блокируется, пока не
придет достаточное к-во данных. Можно указать Timeout, чтобы не блокироваться навечно :)

Еще есть вариант {active, once}. В этом случае сокет запускается в активном режиме,
получает первый пакет данных как сообщение, и сразу переключается в пассивный режим.


## TCP сокет

http://www.erlang.org/doc/man/gen_tcp.html

С TCP сокетом немного сложнее. Сперва нужно начать прослушивание порта:
```erlang
gen_tcp:listen(Port, Options) -> {ok, ListenSocket} | {error, Reason}
```

Затем начать принимать на этом порту соединения для клиентов:
```erlang
accept(ListenSocket) -> {ok, Socket} | {error, Reason}
```

Вызов accept блокируется, пока не появится клиент, желающий подключиться.
И нам нужен отдельный поток на каждого клиента.

Самое простое решение, после listen запускать новый поток для accept.
И этот новый поток, получив соединение с клиентом, опять запускает
новый поток, ожидающий следующего клиента. А сам уходит в цикл для
обработки данных, приходящих от клиента:

```erlang
listen(Port) ->
    {ok, ListenSocket} = gen_tcp:listen(Port, [binary, {active, true}]),
    spawn(?MODULE, accept, [ListenSocket]),
    timer:sleep(infinity), % поток-владелец сокета не должен завершаться
    ok.

accept(ListenSocket) ->
    {ok, _Socket} = gen_tcp:accept(ListenSocket),
    spawn(?MODULE, accept, [ListenSocket]),
    handle().

handle() ->
    receive
        {tcp, Socket, Msg} ->
            io:format("handle ~p~n", [Msg]),
            gen_tcp:send(Socket, Msg),
            handle()
    end.
```

Ну или в пассивном режиме нужно самому читать данные из сокета:
```erlang
recv(Socket, Length, Timeout) -> {ok, Packet} | {error, Reason}
```

Попробуем подключиться telnet клиентом и потестить.


## Бинарные и текстовые протоколы

Два вида протоколов: бинарные с размером впереди, текстовые с разделителем
опробовать оба через telnet

Бинарные обычно устроены по принципу {Tag, Length, Data}
Нужно прочитать заголовок, по нему определить, сколько данных читать дальше.
Размер заголовка 1,2,4 байта
Реализация вручную. Или готовые настройки в gen_tcp.

Примеры: ANS1 (как там правильно?), BERT, Protocol Buffer, Thrift

Текстовые нужно читать побайтно и накапливать в буфере, пока не встретится символ
окончания пакета. Обычно 0 - zero byte.

Примеры: JSON, XML
данные могут быть сжаты, и тогда их нужно прочитать как бинарные, распаковать,
и потом интерпретировать


## Ranch Acceptor Pool

Эта реализация работает, но не очень эффективно. Гораздо эффективнее заранее создать пул
из пары сотен процессов, которые будут висеть в gen_tcp:accept и ждать клиентских соединений.
Тогда установка соединений будет быстрее.

Это реализовано в Ranch Acceptor Pool

http://yzh44yzh.by/post/ranch.html

Надежный базис для построения своего TCP сервера. Поверх него построен cowboy :)

И я использовал в своих проектах.

TODO: пример использования
