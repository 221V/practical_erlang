TODO протестировать и вставить код

# gen_server

Хороший подход к изучению gen_server – написать его самому. Такой
подход выбрали и Joe Armstrong (Programming Erlang, глава 16), и Fred
Hebert (LYSE, глава What is OTP?).

Пойдем и мы тем же путем. Напишем свой gen_server в 6 этапов.


## 1-й этап, простейший цикл.

Нам нужен поток, который никогда не завершается. Используем для этого
бесконечную рекурсию.

```
    -module(gs1).
```

Поток запускается, входит в функцию **loop**, проверяет почтовый ящик,
обрабатывает сообщения, и опять входит в функцию **loop**.  Тут важно,
чтобы это была хвостовая рекурсия. Иначе будет расти память на стеке и
в какой-то момент нода упадет из-за нехватки памяти.

Можно предусмотреть нормальное завершение потока. Для этого добавим
обработку сообщения **stop**, получив которое, поток не будет вызывать
**loop**. И, таким образом, завершится.


## 2-й этап, цикл c состоянием.

Добавим хранимое состояние.

```
    -module(gs2).
```

Теперь функция **loop** получает аргумент. Это состояние потока. После
**spawn** он имеет некое начальное состояние. В данном случае это
массив. Но это может быть любая структура данных.

Затем поток может модифицировать эту структуру, и в последующие вызовы
**loop** передавать новое состояние. Таким образом, не имея
изменяемых переменных, мы все-таки имеем изменяемое состояние потока в
его стеке.

Тут мы усложнили форматы сообщений, которые умеет обрабатывать поток.
И сформировали некое АПИ: добавление и удаление элементов и вывод их
на консоль.


## 3-й этап, горячее обновление кода.

```
    -module(gs3).
```

Здесь мы заменили вызовы **loop(State)** на **?MODULE:loop(State)**.
Тем самым мы заменили локальный вызов функции (только по ее имени),
на глобальный вызов (по имени модуля и функции).

Нода может держать в памяти 2 версии модуля. Допустим, при создании
потока и вызове loop, он начал выполнять версию 1 и прошел несколько
итераций рекурсии. Тем временем, мы изменили код, скомпилировали, и
загрузили в ноду версию 2. Пока текущая итерация не завершена, поток
все еще выполняет версию 1. Но следующий вызов loop уже попадет в
версию 2.

На следующих этапах мы уже не будем останавливать поток, а будем
пользоваться горячим обновлением кода.


## 4-й этап, синхронное АПИ.

Это хорошо, что наш сервер умеет хранить состояние и менять его в
зависимости от запросов клиентов. Но было бы неплохо, чтобы сервер
умел что-нибудь отвечать клиенту.


```
    -module(gs4).
```

TODO код и комментарии


## 5-й этап, матчинг сообщений по Ref.

```
    -module(gs5).
```

TODO код и комментарии


## 6-й этап, убираем дублирование кода.

```
    -module(gs6).
```

TODO код и комментарии


## 7-й этап, добавляем таймаут.

```
    -module(gs7).
```

TODO код и комментарии


## 8-й этап, монитор, обработка ошибок.

```
    -module(gs8).
```

TODO код и комментарии


## Комментарии по этой реализации.

Мы реализовали только часть gen_server, а именно **gen_server:call/handle_call**.

API gen_server еще включает:

**start/init**
TODO

**cast/handle_cast**
TODO

**message/handle_info**
TODO

**terminate**
TODO

**code_change**
TODO

Но и это еще не все. В стандартной реализации gen\_server есть возможность
сделать call/cast на несколько нод в кластере; есть возможность запаковать
состояние, чтобы оно занимало меньше места в памяти и другие фишки.

## Пример настоящего модуля.

реализующего поведение gen_server
https://github.com/yzh44yzh/e_prof/blob/master/src/e_prof.erl


## Отложенная инициализация

Вызов init блокирует родительский процесс, причем с timeout = infinity
по умолчанию. Желательно оставлять эту функцию легковесной и
возвращать управление родителю как можно быстрее.

Если инициализация сервера требует долгих действий, то такие вещи
лучше делать отложено.

```
init(Args) ->
    State = ...
    self() ! heavy_init,
    {ok, State}.

handle_info(heavy_init, State) ->
    NewState = ...
    {noreply, NewState};
```

Устанавливать соединение с базой данных, запрашивать какие-то данные из внешнего
источника, создавать большие объекты в памяти -- все это стоит делать отложено.


## Deadlock на gen_server:call

С этим сталкивается почти каждый новичок в Erlang. И я тож столкнулся.

Нельзя делать gen\_server:call на самого себя внутри handle\_call.
Бывают более сложные варианты, когда из handle\_call вызвается какая-то функция,
и уже в ней, или где-то в цепочке вызовов gen\_server:call.

TODO объяснить, почему нельзя
